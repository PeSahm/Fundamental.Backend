---
applyTo: '**'
---


SoftwareFactory
/
Version Control Guidelines (CG2400)
Mostafa Esmaili
Edit





Share


Version Control Guidelines (CG2400)



By Merijn van den Kroonenberg
18-06-2025

20

thumbs up
1
Legacy editor
Most of these guidelines are taken from https://chris.beams.io/posts/git-commit/ read it for more background information. It is Git oriented but most guidelines are appropriate for any version control system.

Separate subject from body with a blank line (CG2401) 
From the git commit main page:

Though not required, it’s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, Git-format-patch(1) turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.
But this is equally true for SVN.

Firstly, not every commit requires both a subject and a body. Sometimes a single line is fine, especially when the change is so simple that no further context is necessary. For example:

Fix typo in introduction to user guide
Nothing more need be said; if the reader wonders what the typo was, she can simply take a look at the change itself.

However, when a commit merits a bit of explanation and context, you need to write a body. For example:

Derezz the master control program

MCP turned out to be evil and had become intent on world domination.
This commit throws Tron's disc into MCP (causing its deresolution)
and turns it back into a chess game.
There are a number of other contexts in Git where the distinction between subject line and body kicks in—but none of them work properly without the blank line in between. The SVN log also shows a clear title if you use a blank line as separator.

Limit the subject line to 50 characters (CG2402) 
50 characters is not a hard limit, just a rule of thumb. Keeping subject lines at this length ensures that they are readable, and forces the author to think for a moment about the most concise way to explain what’s going on.

Tip: If you’re having a hard time summarizing, you might be committing too many changes at once. Strive for atomic commits (see CG2409).
Git tools might truncate any subject line longer than 72 characters with an ellipsis:

gh2

So shoot for 50 characters, but consider 72 the hard limit. The ticket number prefix (see CG2408) and "(Merge)" prefix don't count towards the 50 character limit.

Capitalize the subject line (CG2403) 
This is as simple as it sounds. Begin all subject lines with a capital letter.

For example:

Accelerate to 88 miles per hour
Instead of:

accelerate to 88 miles per hour
Do not end the subject line with a period (CG2404) 
Trailing punctuation is unnecessary in subject lines. Besides, space is precious when you’re trying to keep them to 50 chars or less.

Use the imperative mood in the subject line (CG2405) 
Imperative mood just means “spoken or written as if giving a command or instruction”. A few examples:

Clean your room
Close the door
Take out the trash
The imperative can sound a little rude; that’s why we don’t often use it. But it’s perfect for Git commit subject lines. One reason for this is that Git itself uses the imperative whenever it creates a commit on your behalf.

For example, the default message created when using git merge reads:

Merge branch 'myfeature'

So when you write your commit messages in the imperative, you’re following Git’s own built-in conventions. For example:

Refactor subsystem X for readability
Update getting started documentation
Remove deprecated methods
Release version 1.0.0
Writing this way can be a little awkward at first. We’re more used to speaking in the indicative mood, which is all about reporting facts. That’s why commit messages often end up reading like this:

Fixed bug with Y
Changing behavior of X
And sometimes commit messages get written as a description of their contents:

More fixes for broken stuff
Sweet new API methods
To remove any confusion, here’s a simple rule to get it right every time.

A properly formed Git commit subject line should always be able to complete the following sentence:

If applied, this commit will your subject line here
For example:

If applied, this commit will refactor subsystem X for readability
If applied, this commit will update getting started documentation
If applied, this commit will remove deprecated methods
If applied, this commit will release version 1.0.0
If applied, this commit will merge pull request #123 from user/branch
Notice how this doesn’t work for the other non-imperative forms:

If applied, this commit will fixed bug with Y
If applied, this commit will changing behavior of X
If applied, this commit will more fixes for broken stuff
If applied, this commit will sweet new API methods
Remember: Use of the imperative is important only in the subject line. You can relax this restriction when you’re writing the body.
Wrap the body at 72 characters (CG2406) 
This is a Git specific guideline. Git does not wraps text automatically. When you write the body of a commit message, you must mind its right margin, and wrap text manually.

The recommendation is to do this at 72 characters, so that Git has plenty of room to indent text while still keeping everything under 80 characters overall.

Use the body to explain what and why vs. how (CG2407) 
In default code is (or should be) self-explanatory. Therefor, you can leave out details about how a change has been made and focus on the why. Focus in the body on the reasons why the change was made, the way things worked before, the way they work now, and why you decided to solve it the way you did.

This commit from Bitcoin Core is a great example of explaining what changed and why:



commit eb0b56b19017ab5c16c745e6da39c53126924ed6
Author: Pieter Wuille <pieter.wuille@gmail.com>
Date:   Fri Aug 1 22:57:55 2014 +0200

   Simplify serialize.h's exception handling

   Remove the 'state' and 'exceptmask' from serialize.h's stream
   implementations, as well as related methods.

   As exceptmask always included 'failbit', and setstate was always
   called with bits = failbit, all it did was immediately raise an
   exception. Get rid of those variables, and replace the setstate
   with direct exception throwing (which also removes some dead
   code).

   As a result, good() is never reached after a failure (there are
   only 2 calls, one of which is in tests), and can just be replaced
   by !eof().

   fail(), clear(n) and exceptions() are just never called. Delete
   them.
Take a look at the full diff and just think how much time the author is saving fellow and future committers by taking the time to provide this context here and now. If he didn’t, it would probably be lost forever.

In most cases, you can leave out details about how a change has been made. Code is generally self-explanatory in this regard (and if the code is so complex that it needs to be explained in prose, that’s what source comments are for). Just focus on making clear the reasons why you made the change in the first place—the way things worked before the change (and what was wrong with that), the way they work now, and why you decided to solve it the way you did.

The future maintainer that thanks you may be yourself!


Create Atomic Commits (CG2409) 
An “atomic” change revolves around one task or one fix.

The common thought with those new to source control is to commit “at the end of the work day”, or “whenever I feel like it”, or whenever a batch of fixes are complete. Avoid those pitfalls and consider what an “atomic” block of work is and make a commit only when that is complete. It may make your commit history more verbose, but in the end it will make your overall project a lot more flexible for bug fixes, feature migrations, and rollbacks. In addition it is easier to review your own changes during commit and for others to code review your changes.

Atomic Approach
Commit each fix or task as a separate change
Only commit when a block of work is complete
Commit non-functional changes separately (e.g. adding a comment, changing the layout, fixing a typo)
Joint commit for layout file, code behind file, and additional resources
Benefits
Easy to roll back without affecting other changes
Easy to make other changes on the fly
Easy to merge features to other branches
Easy to create a meaningful commit message
Easy to code review
Easy to see if a functional change was intentional, or a bug accidentally introduced while refactoring
Do not force push when branch is under review (CG2410) 
Force pushes rewrites history, and this requires reflog to see the original commits. This requires the reviewer to compare what was actually done and if anything has been changed. Common scenario when this happens is with rebase to resolve conflicts. We want to have a merge commit merging in the target branch in which the conflicts are resolved, with a clear commit message detailing what exactly needed resolving.

Force pushing is allowed only when agreed upon with the reviewer. Rule of thumb: if somebody else looked at the commit(s), don't force push (effectively hiding those commit(s)).

Use merge commits for integrating branches (CG2411) 
Mostly applicable for merging feature, hotfix and release branches into target branches. Instead of rebase and/or squash, use a merge commit. This allows us to see the entire history and how things became to be, including fixes. The merge commit itself must have a proper description of what's being merged.

In the case of merging the target branch into the current branch (to pull in changes), then also use a merge commit if the branch is already under review (CG2410). In this merge commit yo


COMMMIT TITLE SHOULD BE LESS THAN 72 characters
COMMIT Body SHOULD WRAP AT 80 CHARACTERS PER LINE
BODY SHOULD EXPLAIN WAY THE CHANGE WAS MADE RATHER THAN HOW